## 测试开发工程师面经

* **操作系统**
  * 线程和进程:
    * 进程：一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。
    * 线程：进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。
  * 线程和进程的区别:
    - 根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位
    - 资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。
    - 包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。
    - 内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的
    - 影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。
    - 执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行
  * 线程的运行状态
    * 1.新建（new）：创建一个县城对象。
    * 2.可运行（runnable）：调用start()方法，该线程处于就绪状态，等待线程调度选中，获取CPU使用权。
    * 3.运行（runing）：就绪状态是进入到运行状态的唯一入口。
    * 4.阻塞（block）：处于运行状态中的线程由于某种原因，暂时放弃对 CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被 CPU 调用以进入到运行状态。
    * 5.死亡（dead）：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。
* **Java**
  * 三大特性（重点多态）
    * 封装
      * 封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。
    * 继承
      * 继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。
      - 子类拥有父类非 private 的属性和方法。
      - 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
      - 子类可以用自己的方式实现父类的方法。（以后介绍）。
    * 多态
      * 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，**即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定**。
      * 在Java中有两种形式可以实现多态：**继承**（多个子类对同一方法的重写）和**接口**（实现接口并覆盖接口中同一方法）。
      * **方法重载**（overload）实现的是编译时的多态性（也称为前绑定），而**方法重写**（override）实现的是运行时的多态性（也称为后绑定）。
  * [Java对象的生命周期](https://www.jianshu.com/p/72a0e26d35bc)
    * 创建阶段(Created)
    * 应用阶段(In Use)
    * 不可见阶段(Invisible)
    * 不可达阶段(Unreachable)
    * 收集阶段(Collected)
    * 终结阶段(Finalized)
    * 对象空间重分配阶段(De-allocated)
  * 对象的拷贝
    * 浅拷贝（shadow copy）：浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。
      * 如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。
    * 深拷贝（deep copy）：深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。
      * 那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。
    * 延迟拷贝（lazy copy）
  * 导致内存泄漏的原因
    * 长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。
    
* **数据结构**
  * ArrayList 和 LinkedList 的区别是什么？
    - 数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。
    - 随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。
    - 增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。
    - 内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。
    - 线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全。


* **数据库**
  * 数据库主键、外键
  
  |分类|主键|外键|索引|
  |:---:|:---:|:---:|:---:|
  |定义|唯一标识一条记录，不能重复，不允许为空|另一个表的主键，可以重复，可以为空|对数据库中一列或多列的值进行排序的一种结构|
  |作用|保护数据的完整性|和其他表建立联系|提高查询排序的效率|
  |数量|一个|多个|多个唯一|
  |添加|ALTER TABLE “表名” ADD PRIMARY KEY (字段名)|ALTER TABLE “表名” ADD FOREIGN KEY (字段名) REFERENCES “另一张表名”(字段名)|ALTER TABLE “表名” ADD INDEX (字段名)|

  * 索引
    * 索引的类型
      * 主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。
      * 唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引（UNIQUE）。
      * 普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。
      * 全文索引：是目前搜索引擎使用的一种关键技术。
      
    * 索引的基本原理
      - 把创建了索引的列的内容进行排序
      - 对排序结果生成倒排表
      - 在倒排表内容上拼上数据地址链
      - 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据
      
    * 索引的优缺点
      * 索引的优点
         - 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
         - 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
      * 索引的缺点
         - 时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；
         - 空间方面：索引需要占物理空间。
  * 手撕
    * 一个用户信息表、一个用户订单表，把所有用户订单信息输出（提醒用右连接）
      * left join （左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录。
      * right join （右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。
      * inner join （等值连接或者叫内连接）：只返回两个表中连接字段相等的行。
      * full join （全外连接）：返回左右表中所有的记录和左右表中连接字段相等的记录。
    * 给定商品和商品价格，找出价格最低的五个商品
    ```sql
    select good,price from table order by price asc limit 5
    # 价格最高的5个
    select good,price from table order by price desc limit 5
    ```
* **网络**
  * 输入url之后，页面发生了什么
  * TCP
    * 三次握手
    * 四次挥手
  * [HTTP和HTTPS的区别](https://www.cnblogs.com/klb561/p/10289199.html)
    * 基本概念：
      * HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
      * HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。
        * HTTPS的主要作用：
          * 一种是建立一个信息安全通道，来保证数据传输的安全；
          * 另一种就是确认网站的真实性。
    * 主要区别：
      * https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
      * http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
      * http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
      * http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
  * 长连接、短连接
    * TCP 短连接
      * 短连接一般只会在client/server间传递一次读写操作。
      * 短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。
    * TCP 长连接
      * Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。
  * url的组成
    ```
    <scheme>://<user>:<password>@<host>:<port>/<path>:<params>?<query>#<frag>
    ```
  * [状态码](https://www.jianshu.com/p/f9c6ed6fa35e)
    * 1XX 信息提示
    * 2XX 请求成功
    * 3XX 重定向
    * 4XX 客户端错误
    * 5XX 服务器错误
  * [GET和POST](https://www.oschina.net/news/77354/http-get-post-different)
  
  |分类|GET|POST|
  |:---:|:---:|:---:|
  |回退/刷新|无害|数据会被重新提交|
  |Book|可收藏为书签|不可收藏为书签|
  |Cache|能被缓存|不能被缓存|
  |编码类型|application/x-www-form-urlencoded|application/x-www-form-urlencoded 或 multipart/form-data为二进制数据使用多重编码|
  |历史|参数表留在浏览器历史记录中|参数不会保留在浏览器历史记录中|
  |数据类型|ACII|没有限制，允许二进制|
  |安全性|与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！|POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。|
  |可见性|	数据在 URL 中对所有人都是可见的|数据不会显示在 URL 中|
  
  * **!** HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 
  * **!** 数据包
    * 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
    * 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

* **测试**
  * 对测试的理解
    * 测试流程
      * 测试计划->测试设计（测试用例，测试数据）->测试执行（单元测试，继承测试，系统测试，回归测试）
  * 测试理论
    * [测试用例设计方法](https://www.cnblogs.com/deliaries/p/12393843.html)
      * 等价类划分
      * 边界值分析法
      * 错误推测法
      * 因果图方法
      * 场景法
    * 白盒测试（又叫功能测试或数据驱动测试）：已知产品的内部工作过程，可以通过测试证明每种内部操作是否符合设计规格要求，所有内部成分是否以经过检查。
    * 测试方法
      * 1.代码检查法
      * 2.静态结构分析法
      * 3.静态质量度量法
      * 4.逻辑覆盖法（语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖和路径覆盖）
      * 5.基本路径测试法
      * 6.域测试
      * 7.符号测试
      * 8.Z路径覆盖
      * 9.程序变异  
    * 黑盒测试（又称为结构测试或逻辑驱动测试）：已知产品的功能设计规格，可以进行测试证明每个实现了的功能是否符合要求。
    * 测试方法
      * 1.等价类划分（等价类是指某个输入域的集合，它表示对揭露程序中的错误来说，集合中的每个输入条件是等效的）
      * 2.边值分析法：列出单元功能、输入、状态及控制的合法边界值，设计测试用例，包含全部边界值的方法。
      * 3.因果图：
      * 4.错误推测法
      * 5.判定表法
      * 6.状态迁移法
      * 7.正交实验法
    * 灰盒测试：介于白盒测试与黑盒测试之间的，可以这样理解，灰盒测试关注输出对于输入的正确性，同时也关注内部表现，但这种关注不象白盒那样详细、完整，只是通过一些表征性的现象、事件、标志来判断内部的运行状态。
    
    |比较项|白盒|黑盒|灰盒|
    |:---:|:---:|:---:|:---:|
    |测试阶段|单元测试|系统测试|集成测试|
    |评估标准|逻辑覆盖率|需求规格覆盖率|接口覆盖率|
    |特点|能及早的发现问题、定位问题快速；对接口、需求程序调用测试不是很好|解决问题的代价大，很难发现模块内部问题|对测试用例的设计需要花时间|
  * 对登录界面进行测试
    * 功能测试
      * 正确用户名&密码
      * 错误用户名&密码
      * 登录成功是否能够跳转到正确的页面
      * 用户名密码的规范
      * 用户名密码前后有空格的处理
      * 密码是否已星号显示
    * 界面测试
      * 布局
      * 界面外观
      * 图片、颜色、字体、超链接是否能够正常显示
    * 性能测试
      * 打开页面时间
      * 登录时间
      * 并发测试
    * 安全性测试（登录）
      * 登录成功后生成的Cookie，是否是httponly (否则容易被脚本盗取)
      * 用户名和密码是否通过加密的方式，发送给Web服务器
      * 用户名和密码的输入框，应该屏蔽SQL 注入攻击
      * 用户名和密码的的输入框，应该禁止输入脚本 （防止XSS攻击）
      * 错误登陆的次数限制（防止暴力破解）
    * 可用性测试
      * 是否可以全用键盘操作，是否有快捷键
      * 输入用户名，密码后按回车，是否可以登陆
    * 兼容性测试
      * 主流浏览器
      * 不同平台
      * 移动端
      * 不同分辨率
    * 软件辅助性测试
      * 高对比度下是否显示正常 
  * [微信发红包如何需要测试哪些方面](https://blog.csdn.net/yimixgg/article/details/94741910)

    * 功能测试
    * 兼容性测试
    * 性能测试
    * UI测试&易用性测试
    * 中断测试
    * 网络测试
  * [用过哪些抓包工具](https://zhuanlan.zhihu.com/p/44912855)
    * fiddler
    * wireshark
* **linux**
  * 命令
    * 修改用户权限 chown
    * 查看当前端口的进程状态 netstat
    * 查看当前路径 pwd
    * 查看文档的后100行 tail -n 100 filename 
* **手撕**
  * 两个栈实现队列
  * 快排、冒泡（复杂度分析）
  * 查找字符串中出现最多的字符
  * 合并有序链表并去重
  * 将一个数分解成质数积
  * 判断回文数
